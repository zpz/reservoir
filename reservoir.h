/**
 * References:
 *
 * Water E. Brown, 2013,
 * Random number generation in C++11,
 * Document #: WG21 N3551.
 *
 * Walter E. Brown, 2013,
 * Three <random>-related proposals,
 * Document #: WG21 N3547.
 */


#ifndef RESERVOIR_H
#define RESERVOIR_H


// FIXME:
// Use version 2 of H5Dopen H5Acreate and H5Dcreate
// This makeshift solution is probably related to the fact
// that HDF5 version (1.8.4?) on Colossus is slightly lower
// than on my laptop, which is 1.8.9.
//
// NOTE: this should come BEFORE #include "hdf5.h".

#define H5Dopen_vers 2
#define H5Gopen_vers 2
#define H5Gcreate_vers 2
#define H5Dcreate_vers 2

#include "hdf5.h"



#include <algorithm>
#include <cassert>
#include <cstddef>    // size_t
#include <cstdint>    // uintmax_t
#include <memory>
#include <random>


typedef uintmax_t max_size_t;



/// Simple functions intended for naive, leisurely use.



std::default_random_engine & global_urng();

// Seed the global URNG by a specified seed.
// Calling this function with the same seed will make the global URNG
// generate the same stream of random numbers.
void global_seed(unsigned int);

// Seed the global URNG by a hardware or environment (e.g. system time)
// dependent value to achieve non-reproducible stream of random numbers
// generated by the global URNG.
// Return the seed used, which may be recorded and reused later in a
// call to 'global_seed' in order to reproduce the random stream.
unsigned int global_randomize();
unsigned int global_randomise();


// Pick an integer value uniformly in from,..., thru (inclusive).
int pick_a_number(int from, int thru);


// Pick a real value uniformly in (from, to).
double pick_a_number(double from, double upto);



/*
 * The following three functions are simple enough that
 * they may as well coded in place wherever needed.
 *

// Upon return, the array 'mask' has 'k' 1's and 'n - k' 0's
// randomly distributed in the first 'n' elements.
template<typename int_t, typename URNG>
void random_mask(int * mask, int_t n, int_t k, URNG && g)
{
    assert(k > 0 && k < n);
    std::fill_n(mask, k, 1);
    std::fill_n(mask + k, n - k, 0);
    std::shuffle(mask, mask + n, g);
}



template<typename int_t>
void random_mask(int * mask, int_t n, int_t k)
{
    return random_mask(mask, n, k, global_urng());
}



// Upon return, the first 'k' elements of the index array 'indices'
// are a random sample (without replacement) of 'k' elements in
// 0, 1, ..., n-1.
// The caller makes sure 'indices' can hold at least 'n' elements.
template<typename int_t>
void random_indices(int_t * indices, int_t n, int_t k)
{
    std::iota(indices, indices + n, 0);
    std::shuffle(indices, indices + n, global_urng());
}
*/


/*
 * References for weightd reservoir sampling:
 *
 * Graham Cormode, Vladislav Shkapenyuk, Divesh Srivastava, and Bojian
 * Xu, 2009,
 * Forward decay: a practical time decay model for streaming systems,
 * ICDE '09: IEEE 25th International Conference on Data Engineering.
 *
 * Noga Alon, Nick Duffield, Carsten Lund, Mikkel Thorup, 2005,
 * Estimating arbitrary subset sums with few probes.
 *
 * Pavlos S. Efraimidis, Paul G. Spirakis, 2006,
 * Weighted random sampling with a reservoir,
 * Information Processing Letters 97 (2006) 181--185.
 */
class weighted_reservoir
{
    public:
        weighted_reservoir(size_t cap, double alph);

        weighted_reservoir();
            // Use this form only when the reservoir is to be imported
            // from a disk file; otherwise use the other form.

        void clear();

        bool empty() const;

        double alpha() const;

        size_t capacity() const;


        void keep_n_append(
                size_t n_provided
                    // Number of new data points provided to the
                    // reservoir.
                );

        // Used the following functions after 'keep_n_append'.
        size_t n_kept() const;
        size_t const * idx_kept() const;
            // The first 'n_kept()' entries are indices of
            // pre-existing data points in the reservoir that should
            // be kept.
            // The indices are 0 based and are in terms of the
            // location of a data point in the reservoir before
            // 'keep_n_append' is called.
            //
            // The user should manage to store the new
            // reservoir data set such that these data points
            // are the first block, in the order they appear in
            // these indices.
        size_t n_appended() const;
        size_t const * idx_appended() const;
            // The first 'n_appended()' entries are indices of the
            // provided new data points that should be added
            // into the reservoir.
            // The indices are 0 based and indicate the
            // locations of data points in the 'n_provided' new
            // data points used in 'keep_n_append'.
            //
            // The user should manage to store the new
            // reservoir data set such that these data points
            // are stored after the block specified by
            // 'idx_kept', in the order they appear in
            // 'idx_appended'.


        void remove_n_inject(
                size_t n_provided
                );

        // Used the following functions after 'removed_n_inject'.
        size_t n_removed() const;
        size_t const * idx_removed() const;
            // The first 'n_removed()' entries are indices of
            // pre-existing data points in the reservoir that
            // should be deleted.
            // The indices are 0 based and are in terms of the
            // location of a data point in the reservoir before
            // 'remove_n_inject' is called.
            //
            // The user should manage to store the new
            // reservoir data set such that the pre-existing data points
            // in the reservoir that are not removed stay where they are,
            // whereas the hold vacated by the removed data
            // points are filled by the new data points
            // specified by 'idx_injected'.
        size_t n_injected() const;
        size_t const * idx_injected() const;
            // The first 'n_injected()' entries are indices of the
            // provided new data points that should be inserted
            // into the reservoir.
            // The indices are 0 based and indicate the
            // locations of data points in the 'n_provided' new
            // data points that are used in 'removed_n_inject'.
            //
            // The user should manage to store the new
            // reservoir data set such that these new data
            // points first fill the holes vacated by the points
            // specified in 'idx_removed'; extra ones are
            // appended at the end, all in the order that are
            // specified by 'idx_injected'.


        max_size_t grand_total() const;
            // Total number of data points ever offered to the
            // reservoir. Of these, up to 'capacity' have been chosen to
            // be kept in the reservoir.

        size_t size() const;
            // Number of data points in the reservoir.
            // This is always <= capacity

        max_size_t const * idx_current() const;
            // The first 'reservoir.size()' entries are the '_chosen_times' of the data points
            // existing in the reservoir. These are the indices of the data
            // points, chosen to be staying in the reservoir, in the entire
            // history. By looking at this list, one may verify, for
            // example, more recent data are more likely to stay in the
            // reservoir (which would be the case if 'alpha' is > 0).
            // The largest possible index is
            // 'reservoir.grand_total() - 1'.


        herr_t export_to_file(char const * file_name) const;
        herr_t export_to_file(hid_t loc_id, char const * obj_name) const;

        herr_t import_from_file(char const * file_name);
        herr_t import_from_file(hid_t loc_id, char const * obj_name);

    private:

        double _alpha = 0.;
        size_t _capacity = 0;
            // _alpha and _capacity are set at object initiation
            // or upon import from disk file.
            // Otherwise they are constant during the lifetime of the
            // class object.

        size_t _current_size = 0;
        max_size_t _grand_total = 0;
        max_size_t _ref_L = 0;

        std::unique_ptr<max_size_t[]> _chosen_times = nullptr;
        std::unique_ptr<double[]> _chosen_u = nullptr;

        // The following objects will not be exported to disk files
        // b/c they are of a temporary nature.
        // They will be initiated upon object initiation or disk import.

        int _kept_or_removed = 0;
            // If '1':
            //    'keep_n_append' has just been called, hence the first
            //    '_n_kept_or_removed' entries of '_idx_kept_or_removed' are
            //    indices of keeping.
            // If '2':
            //    'remove_n_inject' has just been called, hence the
            //    first '_n_kept_or_removed' entries of '_idx_kept_or_removed'
            //    are indices of removing.
            // In either case, the first '_n_appended_or_injected'
            // entries of '_idx_appended_or_injected' are indices of new
            // data points. The arrangement of the data points in the
            // reservoir depends on the value of '_kept_or_removed'.
        size_t _n_kept_or_removed = 0;
        size_t _n_appended_or_injected = 0;
        std::unique_ptr<size_t[]> _idx_kept_or_removed;
        std::unique_ptr<size_t[]> _idx_appended_or_injected;


        herr_t export_to_file(hid_t) const;
        herr_t import_from_file(hid_t);
};



#endif  // RESERVOIR_H

